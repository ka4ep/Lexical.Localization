<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ output extension=".cs" #>
<#
    string dir = Path.GetDirectoryName(Host.TemplateFile);
    string srcDir = dir; //Path.Combine(dir, ".", "LocalizationKey");
    string srcFilename = Path.Combine(srcDir, "LocalizationKey.cs");
    string srcText = File.ReadAllText(srcFilename);
    string srcCode = GetRegion(srcText, "Code");
    srcCode = Regex.Replace(srcCode, @"([^I])LocalizationKey(\W)", m => m.Groups[1].Value + "StringLocalizerKey" + m.Groups[2].Value);    
    //srcCode = srcCode.Replace("ILocalizationKeyComparer", "StringLocalizerComparer");
    srcCode = srcCode.Replace("/*TypeSectionInterfaces*/", ", IStringLocalizer<T>");
   

    string srcInterfaces = GetRegion(srcText, "Interfaces");
#>
// --------------------------------------------------------
// Copyright:      Toni Kalajainen
// Date:           9.10.2018
// Url:            http://lexical.fi
// --------------------------------------------------------
using System;
using System.Text;
using System.Linq;
using System.Linq.Expressions;
using System.Dynamic;
using System.Threading;
using System.Reflection;
using System.Diagnostics;
using System.Globalization;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using Lexical.Localization;
using Lexical.Localization.Plurality;
using Lexical.Localization.Internal;

namespace Lexical.Localization
{
    using Microsoft.Extensions.Localization;

    /// <summary>
    /// StringLocalizerKey that implements and is assignable to following interfaces:
    ///     <see cref="IStringLocalizer"/>
    ///     <see cref="IStringLocalizerFactory"/>
    ///     <see cref="ILocalizationKey"/>
    /// </summary>
    [DebuggerDisplay("{DebugPrint()}")]
    [Serializable]
    public class StringLocalizerKey : LinePart, 
<#= srcInterfaces #>,
        IStringLocalizer, IStringLocalizerFactory, IStringLocalizerKey
    {
<#= srcCode #>


        /// <summary>
        /// Create Resource key part.
        /// </summary>
        /// <param name="basename"></param>
        /// <param name="location"></param>
        /// <returns></returns>
        public IStringLocalizer Create(string basename, string location) => new _Resource(Appender, new _Assembly(Appender, this, location), basename);

        /// <summary>
        /// Create Type key part.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public IStringLocalizer Create(Type type) => typeConstructor.Create(type, this);

        /// <summary>
        /// Create Culture key part.
        /// </summary>
        /// <param name="newCulture"></param>
        /// <returns></returns>
        public IStringLocalizer WithCulture(CultureInfo newCulture)
        {
            // Find culture key
            ILinePart oldCultureKey = this.GetCultureKey();
            // No culture key, create new
            if (oldCultureKey == null) return newCulture == null ? this : new _Culture(Appender, this, null, newCulture);
            // Old culture matches the new, return as is
            if (oldCultureKey?.GetParameterValue() == newCulture?.Name) return this;

            // Replace culture
            ILinePart beforeCultureKey = oldCultureKey?.PreviousPart;
            if (beforeCultureKey == null) throw new InvalidOperationException("Cannot change culture when culture is the root key.");
            // Read parameters
            List<(string, string)> parameters = new List<(string, string)>();
            for (ILinePart k = this; k != oldCultureKey; k = k.PreviousPart)
                if (k is ILineParameterPart parameterKey && parameterKey.ParameterName != null)
                    parameters.Add((parameterKey.ParameterName, parameterKey.ParameterValue));
            // Assign new culture
            ILinePart result = newCulture == null ? beforeCultureKey : beforeCultureKey.Culture(newCulture);
            // Apply parameters
            for (int i = parameters.Count - 1; i >= 0; i--)
                result = result.Parameter(parameters[i].Item1, parameters[i].Item2); // <- XXX Broken, doesn't use correct type
            return (IStringLocalizer)result;
        }

        /// <summary>
        /// Get localized string.
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public LocalizedString this[string name] 
        { 
            get {
                ILocalizationKey key = this.Key(name);
                LocalizationString printedString = key.ResolveFormulatedString();
                if (printedString.Value == null)
                    return new LocalizedString(name, key.BuildName(), true);
                else
                    return new LocalizedString(name, printedString.Value);
                }
        }

        /// <summary>
        /// Create localized string with format arguments.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="arguments"></param>
        /// <returns></returns>
        public LocalizedString this[string name, params object[] arguments] 
        { 
            get {
                ILocalizationKey key = this.Key(name).Format(arguments);
                LocalizationString printedString = key.ResolveFormulatedString();
                if (printedString.Value == null)
                    return new LocalizedString(name, key.BuildName(), true);
                else
                    return new LocalizedString(name, printedString.Value);
                }
        }

        /// <summary>
        /// Get all strings as localized strings.
        /// </summary>
        /// <param name="includeParentCultures"></param>
        /// <returns></returns>
        public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures)
        {
            ILocalizationStringLinesEnumerable collections = this.FindAsset() as ILocalizationStringLinesEnumerable;
            if (collections == null) return null;

            CultureInfo ci = null;
            if (includeParentCultures && ((ci = this.GetCultureInfo()) != null))
            {
                IEnumerable<LocalizedString> result = null;
                while (true)
                {
                    IEnumerable<KeyValuePair<string, IFormulationString>> strs = collections?.GetAllStringLines(this);
                    if (strs != null)
                    {
                        IEnumerable<LocalizedString> converted = ConvertStrings(strs);
                        result = result == null ? converted : result.Concat(converted);
                    }

                    if (ci.Parent == ci || ci.Parent == null || ci.Name == ci.Parent?.Name) break;
                }
                return result;
            }
            else
            {
                IEnumerable<KeyValuePair<string, IFormulationString>> strs = collections?.GetAllStringLines(this);
                return strs == null ? null : ConvertStrings(strs);
            }
        }

        /// <summary>
        /// Convert strings to localized strings.
        /// </summary>
        /// <param name="lines"></param>
        /// <returns></returns>
        IEnumerable<LocalizedString> ConvertStrings(IEnumerable<KeyValuePair<string, IFormulationString>> lines)
        {
            foreach(var kp in lines)
            {
                string value = kp.Value.Text; // <- What kind of value is expected? Is formulation expected?
                yield return new LocalizedString(kp.Key, value);
            }
        }

        /// <summary>
        /// A library of interfaces and extension methods that DynamicMetaObject implementation seaches from when 
        /// invoked with dynamic calls.
        /// </summary>
        public static class Library
        {
            private static Lazy<DynamicObjectLibrary> lazy = new Lazy<DynamicObjectLibrary>(CreateDefault);

            /// <summary>
            /// Library of methods, fields and properties for dynamic object.
            /// </summary>
            public static DynamicObjectLibrary Default => lazy.Value;

            /// <summary>
            /// Create library of methods, fields and properties for dynamic object implementation.
            /// </summary>
            /// <returns></returns>
            public static DynamicObjectLibrary CreateDefault()
                => LocalizationKey.Library.CreateDefault();
        }
    }

}
<#+
        /// <summary>
        /// Searches text for a region.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="regionName"></param>
        /// <returns>region or ""</returns>
        static string GetRegion(string text, string regionName)
        {
            Regex rex = new Regex(@"#region\s*"+regionName+@"\s*\r?\n\r?(?<region>.*?)\r?\n\s*#endregion\s*"+regionName+@"\s*\r?\n", RegexOptions.Singleline);
            Match match = rex.Match(text);
            return match.Groups[1].Value;
        }
#>