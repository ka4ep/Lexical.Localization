<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    HashSet<string> visited = new HashSet<string>();
#>
using Lexical.Localization;

namespace Lexical.Localization.Inlines
{
    public static class InlineExtensions
    {
<# foreach(var ci in CultureInfo.GetCultures(CultureTypes.AllCultures & ~CultureTypes.NeutralCultures)) { 
        // Skip "" 
        if (ci.Name == "") continue;

        // Get Region
        RegionInfo r = null; try { r = new RegionInfo(ci.Name); } catch (Exception) { }

        // Make language code "[language]-[region]"
        //string code = r == null ? ci.TwoLetterISOLanguageName : ci.TwoLetterISOLanguageName + "-" + r.TwoLetterISORegionName;

        // Make language code "[language]"
        if (ci.Name.Contains("-")) continue;
        string code = ci.TwoLetterISOLanguageName;

        // Add only once
        if (!visited.Add(code)) continue;

        // Make function name
        string funcName = code.Replace("-", "_");
        if (funcName == "as") funcName = "_as";
        if (funcName == "is") funcName = "_is";

        string name = ci.EnglishName;
#>
        /// <summary>
        /// Add inlined <#= name #> language string.
        /// </summary>
        /// <param name="line">key to add string to</param>
        /// <param name="text">language string</param>
        /// <returns>new key</returns>
        public static ILine <#= funcName #>(this ILine line, string text) => line.InlineCulture("<#= code #>", text);

        /// <summary>
        /// Add inlined <#= name #> language string.
        /// </summary>
        /// <param name="line">key to add string to</param>
        /// <param name="text">language string</param>
        /// <returns>new key</returns>
        public static ILine <#= funcName #>(this ILine line, IFormulationString text) => line.InlineCulture("<#= code #>", text);
        
<# } #>

        /// <summary>
        /// Inline <paramref name="valueText"/> to <paramref name="culture"/>.
        /// </summary>
        /// <param name="line"></param>
        /// <param name="culture">subkey in parametrized format, e.g. "Culture:en", or "Culture:en:N:One"</param>
        /// <param name="valueText">value to add</param>
        /// <returns>new line with inlines or <paramref name="line"/></returns>
        /// <exception cref="LineException">If key can't be inlined.</exception>
        static ILine InlineCulture(this ILine line, string culture, string valueText)
        {
            ILineInlines inlines;
            line = line.GetOrCreateInlines(out inlines);
            ILine subline = line.Culture(culture);
            IStringFormat stringFormat = subline.FindStringFormat(StringFormatResolver.Default) ?? CSharpFormat.Instance;
            IFormulationString formulation = stringFormat.Parse(valueText);
            ILine value = subline.Value(formulation);
            inlines[subline] = value;
            return line;
        }

        /// <summary>
        /// Inline <paramref name="value"/> to <paramref name="culture"/>.
        /// </summary>
        /// <param name="line"></param>
        /// <param name="culture">subkey in parametrized format, e.g. "Culture:en", or "Culture:en:N:One"</param>
        /// <param name="value">(optional) value to append, if null removes previously existing the inline</param>
        /// <returns>new line with inlines or <paramref name="line"/></returns>
        /// <exception cref="LineException">If key can't be inlined.</exception>
        static ILine InlineCulture(this ILine line, string culture, IFormulationString value)
        {
            ILineInlines inlines;
            line = line.GetOrCreateInlines(out inlines);
            ILine subline = line.Culture(culture);
            inlines[subline] = subline.Value(value);
            return line;
        }
    }
}
